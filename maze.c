#pragma config(Sensor, S1,     leftUlt,        sensorSONAR)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     frontUlt,       sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     rightUlt,       sensorSONAR)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          ctrlMotor,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma DebuggerWindows("debugStream")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define LEFT_ULTRA_SERVO 0
#define RIGHT_ULTRA_SERVO 1
int currentUltraServo = 0; //left = 0; front = 1; right = 2;
int distance = 0;
int lastGyroErr = 0;
int gyroErr = 0;
int sumGyroErr = 0;
int basePower = 20;
int defaultGyro = 0;
float KpGyro = 1.82;
float KiGyro = 0.039; // sum error
float KdGyro = 2.75;  // recent - last error
float KpUltra = 0.10;
float KiUltra = 0.00005;
float outlierGap = 30.5;
float expectedGap = 10.0;
float gap;
float gapError;
int leftB = 0;
int rightB = 0;
int forwardB = 0;
int carX, carY, carDirection = 0;
int startX = 6, startY = 6,startDirection = 0;;
int endX = 4, endY = 4;
int wayStack[81];
int topOfStack = 0;

void moveWithUltra();
void turnleftWithGyro();
void turnRightWithGyro();
void turn(int to);
void turnTo(int direction);
void pushWayStack(int direction)
{
    wayStack[topOfStack++] = direction;
}
int popWayStack()
{
    return wayStack[--topOfStack];
}
int absolute(int v){
	return v >=0 ? v : -v;
}

// SHORTEST PATH================================
#define CHAR_WIDTH 15
#define CHAR_HEIGHT 5
#define LCD_HEIGHT 125
#define SIZE 9
int map[SIZE][SIZE];
typedef struct _Block
{
    int _type;
    int direction;
    int fromX, fromY;
    int isNewEdge;
    int isTraveled;
    int isUpdating;
    int carWentedDirection;
} Block;

Block pathMap[SIZE][SIZE];
Block searchMap[SIZE][SIZE];

void initPathMap()
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            pathMap[i][j].isTraveled = 0;
            pathMap[i][j].isUpdating = 0;
            pathMap[i][j].isNewEdge = 0;
        }
    }
}

void initSearchMap()
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            searchMap[i][j].direction = -1;
            searchMap[i][j].carWentedDirection = -1;
            searchMap[i][j]._type = 0;
        }
    }
}

char getDirectionSymbol(int direction)
{
    switch (direction)
    {
    case 0:
        return '^';
    case 1:
        return '>';
    case 2:
        return 'v';
    case 3:
        return '<';
    default:
        return 'x';
    }
}

void showStep()
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            if (pathMap[i][j].isTraveled)
            {
                displayStringAt( j * CHAR_WIDTH,LCD_HEIGHT - i * CHAR_HEIGHT, "%c", getDirectionSymbol(pathMap[i][j].direction));
            }
            else
            {
                displayStringAt( j * CHAR_WIDTH,LCD_HEIGHT - i * CHAR_HEIGHT, " ");
            }
        }
    }
}

void showStepInfo()
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            if (pathMap[i][j].isTraveled)
            {
                char ch;
                switch (pathMap[i][j].direction)
                {
                case 0:
                    ch = '^';
                    break;
                case 1:
                    ch = '>';
                    break;
                case 2:
                    ch = 'v';
                    break;
                case 3:
                    ch = '<';
                    break;
                }

                displayStringAt(0, LCD_HEIGHT - 70, "[%d,%d %c %d,%d] ", pathMap[i][j].fromX, pathMap[i][j].fromY, ch, j, i);
            }
            else
            {

                displayStringAt(0, LCD_HEIGHT - 70, "                ");
            }
        }

    }
}
void showSearchStep()
{
		for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            if (searchMap[i][j].carWentedDirection != -1)
            {
                displayStringAt(i * CHAR_WIDTH, LCD_HEIGHT - (SIZE - j) * CHAR_HEIGHT, " %d", searchMap[i][j].carWentedDirection);
            }
            else
            {
                displayStringAt(i * CHAR_WIDTH, LCD_HEIGHT - (SIZE - j) * CHAR_HEIGHT, "%d", -1);
            }
        }
    }
    displayStringAt(0, LCD_HEIGHT - 62, "direction %d\t%c\n", carDirection, getDirectionSymbol(carDirection));
}
void showSearchDirectionStep()
{

    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            displayStringAt(i * CHAR_WIDTH, LCD_HEIGHT - j * CHAR_HEIGHT, "%c", getDirectionSymbol(searchMap[i][j].direction));
        }
        // printf("\n");
    }
}

void showSearchCar()
{

    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            if (i == carY && j == carX)
            {
            	displayStringAt(i * CHAR_WIDTH, LCD_HEIGHT - j * CHAR_HEIGHT, "%c", getDirectionSymbol(carDirection));
            }
            else
            {
            }
        }
        // printf("\n");
    }
}


void moveForward()
{
		switch (carDirection)
    {
    case 0:
        carY--;
        break;
    case 1:
        carX++;
        break;
    case 2:
        carY++;
        break;
    case 3:
        carX--;
        break;
    }
    moveWithUltra();

}

void moveBack()
{
		switch (carDirection)
    {
    case 0:
        carY++;
        break;
    case 1:
        carX--;
        break;
    case 2:
        carY--;
        break;
    case 3:
        carX++;
        break;
    }
		turnleftWithGyro();
		turnleftWithGyro();
		moveWithUltra();
		turnRightWithGyro();
		turnRightWithGyro();
}
void turn(int to)
{
    carDirection = (carDirection + to) & 0b11;
    switch(to){
        case -1:
            turnleftWithGyro();
            break;
        case 1:
            turnRightWithGyro();
            break;
    }
    displayStringAt(60,LCD_HEIGHT - 92,"turn %d\n", to);
}

void turnTo(int direction)
{
		displayStringAt(0,LCD_HEIGHT - 100,"turnTo from %d to %d\n", carDirection, direction);
    while (carDirection != direction)
    {
        turn(1);
    }
    displayStringAt(80,LCD_HEIGHT - 100,"result %d -> %d\n", carDirection, direction);
}
int checkWall(int turn)
{


    float gap;
    switch(turn){
    	case -1:
    		gap = SensorValue[leftUlt];
    		break;
    	case 0:
    		gap = SensorValue[frontUlt];
    		break;
    	case 1:
    		gap = SensorValue[rightUlt];
    		break;
  	}

    return gap < outlierGap;
}

void search()
{

    int step = 0;
    while (1)
    {
        // printf("step %d \t  ==========================================\n", step);
        //while(!SensorValue[button]);

        if (searchMap[carY][carX].carWentedDirection < 2)
        {
            searchMap[carY][carX].carWentedDirection++;

            if (checkWall( searchMap[carY][carX].carWentedDirection - 1))
            {
                int wall;
                switch (carDirection + (searchMap[carY][carX].carWentedDirection - 1))
                {
                case 0:
                    wall = 0b0010;
                    break;
                case 1:
                    wall = 0b0001;
                    break;
                case 2:
                    wall = 0b1000;
                    break;
                case 3:
                    wall = 0b0100;
                    break;
                }
                searchMap[carY][carX]._type |= wall;
                eraseDisplay();
                displayStringAt(0,LCD_HEIGHT - 80,"check %d not move\n", searchMap[carY][carX].carWentedDirection);
                showSearchStep();
                // showSearchDirectionStep();
                // showSearchCar();
            }
            else
            {
                if (searchMap[carY][carX].carWentedDirection - 1 != 0)
                    turn(searchMap[carY][carX].carWentedDirection - 1);

                moveForward();
                if (searchMap[carY][carX].carWentedDirection != -1)
                {
                    moveBack();
                    turnTo(searchMap[carY][carX].direction);
                    searchMap[carY][carX].carWentedDirection++;
                }
                searchMap[carY][carX].direction = carDirection;
                eraseDisplay();
                showSearchStep();
                // showSearchDirectionStep();
                // showSearchCar();
                // printf("check %d move to %d\n", searchMap[carY][carX].carWentedDirection);
           	    displayStringAt(0,LCD_HEIGHT - 80, "check %d move to %d\n", searchMap[carY][carX].carWentedDirection);
           }
        }
        else
        {
            moveBack();
            turnTo(searchMap[carY][carX].direction);
            eraseDisplay();
            showSearchStep();
            // showSearchDirectionStep();
            // showSearchCar();
            // printf("moveBack!\n");
            displayStringAt(0,LCD_HEIGHT-80,"moveBack!\n");
        }
        // printf("carX:%d\tcarY:%d\tcarDirection:%d\n", carX, carY, carDirection);
        displayStringAt(0,LCD_HEIGHT-90,"carX:%d\tcarY:%d\tcarDirection:%d\n", carX, carY, carDirection);
        // printf("end step %d \t  ==========================================\n", step++);
    }
}
// end SHORTEST PATH================================

void turnleftWithGyro()
{ // left

    resetGyro(gyroSensor);
    wait1Msec(500);
    float Kp = 0.75;
    int expect = -95;
    int err;

    int gyro = getGyroDegrees(gyroSensor);
    while (gyro >= expect + 5)
    {
        gyro = getGyroDegrees(gyroSensor);
        err = expect - gyro;
        motor[leftMotor] = (Kp * err);
        motor[rightMotor] = -(Kp * err);
        wait1Msec(10);
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    wait1Msec(1000);

    resetGyro(gyroSensor);
}
void turnRightWithGyro()
{ // right

    resetGyro(gyroSensor);
    wait1Msec(500);
    float Kp = 0.75;
    int expect = 90;
    int err;

    int gyro = getGyroDegrees(gyroSensor);
    while (gyro <= expect - 5)
    {
        gyro = getGyroDegrees(gyroSensor);
        err = expect - gyro;
        motor[leftMotor] = (Kp * err);
        motor[rightMotor] = -(Kp * err);
        wait1Msec(10);
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    wait1Msec(1000);

    resetGyro(gyroSensor);
}
void mov1Block()
{

    int length = 635;
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);
    resetGyro(gyroSensor);
    int distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor)) / 2;

    while (distance < length)
    {
        gyroErr = getGyroDegrees(gyroSensor) + defaultGyro;
        distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor)) / 2;

        sumGyroErr += gyroErr;
        motor[rightMotor] = basePower + KpGyro * gyroErr + KiGyro * (sumGyroErr) + KdGyro * (lastGyroErr - gyroErr);
        motor[leftMotor] = basePower - KpGyro * gyroErr - KiGyro * (sumGyroErr)-KdGyro * (lastGyroErr - gyroErr);

        lastGyroErr = gyroErr;
        wait1Msec(10);
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;
}
int trackingMode = 0; //mode:1 = left; mode:0 = right;

void moveWithUltra()
{
    int length = 630;
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);
    resetGyro(gyroSensor);
    distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor)) / 2;

    int countFindWall = 0;
    float sumGapError = 0;
    float leftGap,frontGap,rightGap;
    trackingMode = 0;
    while (distance < length)
    {
        // gap = SensorValue[ult];
    		/*
    		if(trackingMode)
    			gap = SensorValue[leftUlt];
    		else gap = SensorValue[rightUlt];
    		*/
    		leftGap = SensorValue[leftUlt];
    		frontGap = SensorValue[frontUlt];
    		rightGap = SensorValue[rightUlt];
        if(leftGap < outlierGap || rightGap < outlierGap){
        		if(leftGap < outlierGap){
        				gap = leftGap;
        		}else{
        				gap = rightGap;
        		}
        }else{
        		motor[leftMotor] = basePower;
        		motor[rightMotor] = basePower;
      	}
    		/*
    		if (gap > outlierGap && countFindWall < 2)
        {
            countFindWall++;

            trackingMode = !trackingMode;
        }
        */
        if (countFindWall < 2)
        {
            if (trackingMode)
            {
                gapError = expectedGap - SensorValue[leftUlt];
            }
            else
            {
                gapError = SensorValue[rightUlt] - expectedGap;
            }
        }
        else
        {
            gapError = 0;
        }
        distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor)) / 2;
				sumGapError += gapError;
        motor[leftMotor] = basePower + KpUltra * gapError + KiUltra * sumGapError;
        motor[rightMotor] = basePower - KpUltra * gapError - KiUltra * sumGapError;

        wait1Msec(10);
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;

    resetGyro(gyroSensor);
}
/*
void moveBackWithUltra()
{
    gap = SensorValue[ult];
    int length = -635;
    resetMotorEncoder(leftMotor);
    resetMotorEncoder(rightMotor);
    distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor)) / 2;
		int countFindWall = 0;

    while (distance >= length)
    {
        gap = SensorValue[ult];
        if (gap > outlierGap && countFindWall < 2 || false)
        {
            countFindWall++;

            trackingMode = !trackingMode;
            motor[leftMotor] = 0;
            motor[rightMotor] = 0;
            if (trackingMode)
            {
                turnUltraServo(LEFT_ULTRA_SERVO);
                turnUltraServo(LEFT_ULTRA_SERVO);
            }
            else
            {
                turnUltraServo(RIGHT_ULTRA_SERVO);
                turnUltraServo(RIGHT_ULTRA_SERVO);
            }
        }
        if (countFindWall < 2)
        {
            if (trackingMode)
            {
                gapError = expectedLeftGap - gap;
            }
            else
            {
                gapError = gap - expectedRightGap;
            }
        }
        else
        {
            gapError = 0;
        }
        distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor)) / 2;

        motor[leftMotor] = -(basePower + KpUltra * gapError);
        motor[rightMotor] = -(basePower - KpUltra * gapError);

        //motor[leftMotor] = basePower + KpUltra * gapError;
        //motor[rightMotor] = basePower - KpUltra * gapError;

        wait1Msec(10);
    }
    motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    playSound(soundShortBlip);
    resetGyro(gyroSensor);

}
*/
task main()
{
    playSound(soundFastUpwardTones);
    initPathMap();
    initSearchMap();
    resetAllSensorAutoID();
    carX = startX;
    carY = startY;
    carDirection = startDirection;

		while(1){
			moveWithUltra();
		}
    //search();
    wait10Msec(1000000);
}
