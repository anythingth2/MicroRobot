#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


int lastGyroErr=0;
int gyroErr = 0;
int sumGyroErr =0;
int basePower = 60;
float KP = 1.5;
float K_angle = 2.488 * 1.1;
int defaultGyro = 0;
float KpGyro = 1.8;
float KiGyro = 0.04;
float KdGyro = 2.75;




void moveForwardWithGyro(int block){
	float t = block * 0.95*1000;
	int length = 560*block;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	int distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor))/2;
	while(distance <  length){
		gyroErr = getGyroDegrees(gyroSensor) + defaultGyro;
		distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor))/2;

		sumGyroErr += gyroErr;
		motor[rightMotor] = basePower + KpGyro*gyroErr + KiGyro*(sumGyroErr) + KdGyro*(lastGyroErr - gyroErr);
		motor[leftMotor] = basePower -  KpGyro*gyroErr - KiGyro*(sumGyroErr) - KdGyro*(lastGyroErr - gyroErr) ;

		lastGyroErr = gyroErr;
		wait1Msec(10);
	}
}
void turn(int angle){
	setMotorTarget(leftMotor,-angle*K_angle,basePower/2);
	setMotorTarget(rightMotor,angle*K_angle,basePower/2);
	//waitUntilMotorStop(leftMotor);
	//waitUntilMotorStop(rightMotor);
	wait1Msec(4*1000);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
}
void turnWithGyro(){

	resetGyro(gyroSensor);
	wait1Msec(500);
	float Kp = 0.75;
	int expect = -90;
	int err;

	int gyro = getGyroDegrees(gyroSensor);
	while(gyro >= expect+2){
		gyro = getGyroDegrees(gyroSensor);
		err = expect - gyro;
		motor[leftMotor] = (Kp*err);
		motor[rightMotor] = -(Kp*err);
		wait1Msec(10);

	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
	wait1Msec(1000);

	resetGyro(gyroSensor);
}

void run(){
	for(int i=0;i<5;i++){
		moveForwardWithGyro(10-i*2-1);
		turnWithGyro();
		moveForwardWithGyro(10-i*2-1);
		turnWithGyro();
		//basePower -= 10;
	}
	motor[leftMotor] = 100;
	motor[rightMotor] = -100;

	wait1Msec(10000);
}
task main()
{

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	resetGyro(gyroSensor);
	//defaultGyro = getGyroDegrees(gyroSensor);
	//turnWithGyro();
	run();




}
