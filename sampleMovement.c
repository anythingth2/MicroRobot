#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int distanceLeft=0,distanceRight=0;
int meanDistance=0;
int basePower = 65;
float KP = 1.5;
float K_angle = 2.488 * 1.1;
int defaultGyro = 0;
float KpGyro = 0.75;
float KiGyro = 0;
float KdGyro = 0.35;
void moveForward(int t){
	t *= 10*1.25;
	for(int i=0;i<t;i++){
		distanceLeft = getMotorEncoder(leftMotor);
		distanceRight = getMotorEncoder(rightMotor);
		meanDistance = (distanceLeft + distanceRight) / 2;
		motor[leftMotor] = basePower + (meanDistance - distanceLeft)*KP;
		motor[rightMotor] = basePower + (meanDistance - distanceRight)*KP;
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
		wait1Msec(100);
	}
}
int lastGyroErr=0;
int gyroErr = 0;
int sumGyroErr =0;
void moveForwardWithGyro(int block){
	float t = block * 0.95*1000;

	for(int i = 0;i<t;i+=25){
		gyroErr = getGyroDegrees(gyroSensor) + defaultGyro;

		sumGyroErr += gyroErr;
		motor[rightMotor] = basePower + KpGyro*gyroErr + KiGyro*sumGyroErr + KdGyro*(lastGyroErr - gyroErr);
		motor[leftMotor] = basePower -  KpGyro*gyroErr - KiGyro*sumGyroErr - KdGyro*(lastGyroErr - gyroErr) ;

		lastGyroErr = gyroErr;
		wait1Msec(25);
	}
}
void turn(int angle){
	setMotorTarget(leftMotor,-angle*K_angle,basePower/2);
	setMotorTarget(rightMotor,angle*K_angle,basePower/2);
	//waitUntilMotorStop(leftMotor);
	//waitUntilMotorStop(rightMotor);
	wait1Msec(4*1000);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
}
void turnWithGyro(){
	resetGyro(gyroSensor);


	int gyro = getGyroDegrees(gyroSensor);
	while(gyro > -90){
		motor[leftMotor] = -basePower/5;
		motor[rightMotor] = basePower/5;
		wait1Msec(10);
		gyro = getGyroDegrees(gyroSensor);
	}
	resetGyro(gyroSensor);
}

void run(){
	for(int i=0;i<5;i++){
		moveForwardWithGyro(10-i*2-1);
		turnWithGyro();
		moveForwardWithGyro(10-i*2-1);
		turnWithGyro();
	}
}
task main()
{

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	resetGyro(gyroSensor);
	//defaultGyro = getGyroDegrees(gyroSensor);
	//turnWithGyro();
	run();




}
