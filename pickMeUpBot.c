#pragma config(Sensor, S1, rightColor, sensorEV3_Color)
#pragma config(Sensor, S2, ultSensor, sensorEV3_Ultrasonic)
#pragma config(Sensor, S3, boxColor, sensorLightActive)
#pragma config(Sensor, S4, leftColor, sensorEV3_Color)
#pragma config(Motor, motorA, rightMotor, tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor, motorC, keepBox, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorD, leftMotor, tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define SIZE 10
int simMap[SIZE][SIZE];
int map[SIZE][SIZE];
#define NOT_REACH_TYPE 0
#define EMPTY_TYPE 1
#define ORANGE_TYPE 2
#define BLACK_TYPE 3
const char SYMBOL_TYPE[] = {'-', '+', 'O', 'B'};
#define NORTH_DIRECION 0
#define EAST_DIRECION 1
#define SOUTH_DIRECION 2
#define WEST_DIRECION 3
#define LEFT_HAND -1
#define RIGHT_HAND 1
#define BLOCK_SIZE 26.7
const char SYMBOL_DIRECTION[] = {'^', '>', 'v', '<'};

typedef struct _Car
{
    int x, y;
    int direction;
} Car;
Car car;
const int startX = 9, startY = 9, startDirection = NORTH_DIRECION;

float KpColor = 0.095;
float KiColor = 0.0;
//float KiColor = -0.00000001;
float err;
float sumErr;
int leftCol = 0;
int rightCol = 0;
int boxCol = 0;
int basepower = 50;
int frontult = 0;
int colorOfBox;
int color = 0;
int fullBlackThreshold = 10;

void turn(int to)
{
    car.direction = (car.direction + to) & 0b11;
    //motor[leftMotor] = 15;
    //motor[rightMotor] = 15;
    //wait1Msec(100);
    int angle = 340;
    int offset = 50;
    int _power = 80;
    if (to == RIGHT_HAND)
    {
        moveMotorTarget(leftMotor, angle, -_power);
        moveMotorTarget(rightMotor, angle, _power);
    }
    else
    {
        moveMotorTarget(leftMotor, angle, _power);
        moveMotorTarget(rightMotor, angle,-_power);
    }
    waitUntilMotorStop(leftMotor);
    waitUntilMotorStop(rightMotor);

		moveMotorTarget(leftMotor,offset,-_power);
		moveMotorTarget(rightMotor,offset,-_power);

    waitUntilMotorStop(leftMotor);
    waitUntilMotorStop(rightMotor);

}
void moveForward(int block)
{
		int offset = 200;
    sumErr = 0;
    for (int i = 0; i < block; i++)
    {
    		resetMotorEncoder(leftMotor);
    		resetMotorEncoder(rightMotor);
    		int distance = 0;
        do
        {
            leftCol = getColorReflected(leftColor);
            rightCol = getColorReflected(rightColor);
            err = leftCol - rightCol;
            sumErr += err;
            motor[leftMotor] = -(basepower + KpColor * err + KiColor * sumErr);
            motor[rightMotor] = -(basepower - KpColor * err - KiColor * sumErr);
            wait1Msec(10);
//          distance = -((getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor)) / 2);

        } while (!(leftCol <= fullBlackThreshold && rightCol <= fullBlackThreshold));
        while (leftCol <= fullBlackThreshold && rightCol <= fullBlackThreshold)
        {
            leftCol = getColorReflected(leftColor);
            rightCol = getColorReflected(rightColor);
        }
        resetMotorEncoder(leftMotor);
        resetMotorEncoder(rightMotor);
        do
        {
            leftCol = getColorReflected(leftColor);
            rightCol = getColorReflected(rightColor);
            err = leftCol - rightCol;
            sumErr += err;
            motor[leftMotor] = -(basepower + KpColor * err + KiColor * sumErr);
            motor[rightMotor] = -(basepower - KpColor * err - KiColor * sumErr);
            wait1Msec(10);
	          distance = -((getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor)) / 2);

        } while (distance < offset);
    }
}

void moveBack(int block)
{
    if (block <= 0)
        return;
    turn(LEFT_HAND);
    turn(LEFT_HAND);
    moveForward(block);
    turn(RIGHT_HAND);
    turn(RIGHT_HAND);
}

void turnTo(int direction)
{
    while (car.direction != direction)
    {
        if (car.direction == 0b00 && direction == 0b11)
        {
            turn(RIGHT_HAND);
            continue;
        }
        if (car.direction == 0b11 && direction == 0b00)
        {
            turn(RIGHT_HAND);
            continue;
        }
        if (car.direction < direction)
            turn(RIGHT_HAND);
        else
            turn(LEFT_HAND);
    }
}
int scanLineBlock()
{
    return SensorValue[ultSensor] < BLOCK_SIZE * 5 + 7 ? (int)((SensorValue[ultSensor] - 7) / BLOCK_SIZE) : -1;
}
int readBlockType()
{
    return ORANGE_TYPE;
}

void printMap()
{
    int offsetY = 10;
    int offsetX = 15;
    for (int i = 0; i < 9; i++)
    {
        for (int j = 0; j < 9; j++)
        {
            if (i == car.y && j == car.x)
                displayStringAt(10 + offsetX * j, 115 - offsetY * i, "%c", SYMBOL_DIRECTION[car.direction]);
            else
                displayStringAt(10 + offsetX * j, 115 - offsetY * i, "%c", SYMBOL_TYPE[map[i][j]]);
        }
    }
}
void getColor() // color = 1 is black - color = 2 is orange
{
    colorOfBox = SensorValue[S3];
    if (colorOfBox >= 15 && colorOfBox <= 30)
    {
        color = 1; // black
    }
    else if (colorOfBox >= 45 && colorOfBox <= 50)
    {
        color = 2; //orange
    }
}
void isFound()
{
    frontult = SensorValue[S2]; // ultrasonic
    if (frontult <= 15)
    {
        getColor();
    }
}
void search()
{
    for (int i = 0; i < 4; i++)
    {

        for (int j = 0; j < SIZE - 1; j++)
        {
            moveForward(1);

            turn(LEFT_HAND);

            int foundBlockAt = scanLineBlock();
            if (foundBlockAt != -1)
            {
                int horizontalOffset = 0;
                int verticalOffset = 0;
                switch (car.direction)
                {
                case NORTH_DIRECION:
                    verticalOffset = -1;
                    break;
                case EAST_DIRECION:
                    horizontalOffset = 1;
                    break;
                case SOUTH_DIRECION:
                    verticalOffset = 1;
                    break;
                case WEST_DIRECION:
                    horizontalOffset = -1;
                    break;
                }
                // printf("found block at %d\n", foundBlockAt);
                // getch();
                // displayStringAt(0, 115 - 80, "foundBlockAt : %d", foundBlockAt);
                moveForward(foundBlockAt);
                map[car.y + verticalOffset][car.x + horizontalOffset] = readBlockType();
                // printMap();
                // getch();
                //moveBack(foundBlockAt);

                turn(RIGHT_HAND);
                turn(RIGHT_HAND);
                moveForward(foundBlockAt);
                turn(LEFT_HAND);
                //printMap();
            }
            else
            {

                turn(RIGHT_HAND);
            }
            // printSimMap();
            eraseDisplay();
            printMap();
            // printf("-------------------------------------------------------\n");
        }
        turn(LEFT_HAND);

        // printSimMap();
        eraseDisplay();
        printMap();
        // printf("-------------------------------------------------------\n");
    }
}
void search2(){

		moveForward(1);
		turn(LEFT_HAND);
		moveForward(1);

		for(int i=0;i<SIZE-2;i++){
			for(int j=0;j<SIZE-2;j++){
					if(isFound()){

					}
			}
		}

}
void pickUp()
{
    moveMotorTarget(motorC, 630, 50);
    waitUntilMotorStop(motorC);
}
void Drop()
{
    moveMotorTarget(motorC, -630, -50);
    waitUntilMotorStop(motorC);
}


void initMap()
{
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
        {
            simMap[i][j] = NOT_REACH_TYPE;
            map[i][j] = NOT_REACH_TYPE;
        }
    simMap[3][3] = ORANGE_TYPE;
    simMap[5][7] = ORANGE_TYPE;
    simMap[5][8] = ORANGE_TYPE;
    simMap[7][3] = ORANGE_TYPE;

    simMap[1][2] = BLACK_TYPE;
    simMap[4][6] = BLACK_TYPE;
    simMap[7][5] = BLACK_TYPE;
    simMap[2][5] = BLACK_TYPE;
}

void initCar()
{
    car.x = startX;
    car.y = startY;
    car.direction = startDirection;
}

task main()
{

    initMap();
    initCar();
    search();
}
