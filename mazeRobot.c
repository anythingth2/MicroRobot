#pragma config(Sensor, S1,     ult,            sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          ctrlMotor,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int distance=0;
int lastGyroErr=0;
int gyroErr = 0;
int sumGyroErr =0;
int basePower = 30;
int defaultGyro = 0;
float KpGyro = 1.82;
float KiGyro = 0.039; // sum error
float KdGyro = 2.75; // recent - last error
int leftB=0;
int rightB=0;
int forwardB=0;
int map[9][9] ={ 0,0,0,0,0,0,0,0,0 //8
								,0,0,0,0,0,0,0,0,0 //7
								,0,0,0,0,0,0,0,0,0 //6
								,0,0,0,0,0,0,0,0,0 //5
								,0,0,0,0,0,0,0,0,0 //4
								,0,0,0,0,0,0,0,0,0 //3
								,0,0,0,0,0,0,0,0,0 //2
								,0,0,0,0,0,0,0,0,0 //1
								,0,0,0,0,0,0,0,0,0} //0

void turnleftWithGyro(){ // left

	resetGyro(gyroSensor);
	wait1Msec(500);
	float Kp = 0.75;
	int expect = -91;
	int err;

	int gyro = getGyroDegrees(gyroSensor);
	while(gyro >= expect+5){
		gyro = getGyroDegrees(gyroSensor);
		err = expect - gyro;
		motor[leftMotor] = (Kp*err);
		motor[rightMotor] = -(Kp*err);
		wait1Msec(10);
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
	wait1Msec(1000);

	resetGyro(gyroSensor);
}
void turnRightWithGyro(){ // right

	resetGyro(gyroSensor);
	wait1Msec(500);
	float Kp = 0.75;
	int expect = 93;
	int err;

	int gyro = getGyroDegrees(gyroSensor);
	while(gyro <= expect-5){
		gyro = getGyroDegrees(gyroSensor);
		err = expect - gyro;
		motor[leftMotor] = (Kp*err);
		motor[rightMotor] = -(Kp*err);
		wait1Msec(10);
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
	wait1Msec(1000);

	resetGyro(gyroSensor);
}
void mov1Block(){
	int length = 560;
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	int distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor))/2;
	resetGyro(gyroSensor);
	while(distance <  length){
		gyroErr = getGyroDegrees(gyroSensor) + defaultGyro;
		distance = (getMotorEncoder(leftMotor) + getMotorEncoder(rightMotor))/2;

		sumGyroErr += gyroErr;
		motor[rightMotor] = basePower + KpGyro*gyroErr + KiGyro*(sumGyroErr) + KdGyro*(lastGyroErr - gyroErr);
		motor[leftMotor] = basePower -  KpGyro*gyroErr - KiGyro*(sumGyroErr) - KdGyro*(lastGyroErr - gyroErr) ;

		lastGyroErr = gyroErr;
		wait1Msec(10);
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}
void chk()
{

			leftB = SensorValue[S1];
			moveMotorTarget(motorC, 93, 20);
			waitUntilMotorStop(motorC);
			forwardB = SensorValue[S1];
			wait1Msec(1000);

			moveMotorTarget(motorC, 93, 20);
			waitUntilMotorStop(motorC);
			rightB = SensorValue[S1];
			wait1Msec(1000);

		moveMotorTarget(motorC, -186, -20);
		waitUntilMotorStop(motorC);
		if(leftB<=15 && rightB>20 && forwardB>30) //find left
		{
			mov1Block();
		}
		else if (leftB>20 && rightB<=20 && forwardB>30) //find right
		{
			mov1Block();
		}
		else if (leftB>20 && rightB>20 && forwardB<=15) //find front
		{
			turnleftWithGyro();
			mov1Block();
		}
		else if (leftB<=15 && rightB>20 && forwardB<=15) //find left+front
		{
			turnRightWithGyro();
			mov1Block();
		}
		else if (leftB>20 && rightB<=20 && forwardB<=15) //find right+front
		{
			turnleftWithGyro();
			mov1Block();
		}
		else if (leftB<=20 && rightB<=20 && forwardB<=15) //find left+front+right
		{
			turnRightWithGyro();
			turnRightWithGyro();
			mov1Block();
		}
		else if (leftB<=20 && rightB<=20 && forwardB>30) //find left+right
		{
			mov1Block();
		}
}

task main()
{
	chk();
}
